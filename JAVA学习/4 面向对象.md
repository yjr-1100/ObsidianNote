# 4 面向对象

相信很多Java开发者，在最初接触Java的时候就听说过，Java是一种面向对象的开发语言，那么什么是面向对象呢？

首先，所谓面向对象，其实是指软件工程中的一类编程风格，很多人称呼他们为开发范式、编程泛型（Programming Paradigm）。面向对象是众多开发范式中的一种。除了面向对象以外，还有面向过程、指令式编程、函数式编程等。

虽然这几年函数式编程越来越被人们所熟知，但是，在所有的开发范式中，我们接触最多的主要还是面向过程和面向对象两种。

## 面向过程与面向对象
### 什么是面向过程？

面向过程(Procedure Oriented)是一种以过程为中心的编程思想，是一种自顶而下的编程模式。最典型的面向过程的编程语言就是C语言。

简单来说，面向过程的开发范式中，程序员需要把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。

就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。最典型的用法就是实现一个简单的算法，比如实现冒泡排序。

面向过程进行的软件开发，其代码都是流程化的，很明确的可以看出第一步做什么、第二步做什么。这种方式的代码执行起来效率很高。

但是，面向过程同时存在着代码重用性低，扩展能力差，后期维护难度比较大等问题。

### 什么是面向对象？

面向对象（Object Oriented）的雏形，最早在出现在1960年的Simula语言中，当时的程序设计领域正面临着一种危机：在软硬件环境逐渐复杂的情况下，软件如何得到良好的维护？

面向对象程序设计在某种程度上通过强调可重复性解决了这一问题。目前较为流行的面向对象语言主要有Java、C#、C++、Python、Ruby、PHP等。

简单来说，面向对象的开发范式中，程序员将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。

就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。比如:想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。

面向对象的编程方法之所以更加受欢迎，是因为他更加符合人类的思维方式。这种方式编写出来的代码扩展性、可维护性都很高。

与其说面向对象是一种开发范式，倒不如说面向对象是一种对现实世界的理解和抽象的方法。通过对现实世界的理解和抽象，在运用封装、继承、多态等方法，通过抽象出对象的方式进行软件开发。

## 面向对象的三大特征

我们说面向对象的开发范式，其实是对现实世界的理解和抽象的方法，那么，具体如何将现实世界抽象成代码呢？这就需要运用到面向对象的三大特性，分别是**封装**性、**继承**性和**多态**性。

### 封装

所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，**对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。**

```java
/** * 矩形 */
class Rectangle { 
	/** * 设置矩形的长度和宽度 */ 
	public Rectangle(int length, int width) {
		this.length = length; 
		this.width = width;
	} 
	/** * 长度 */ 
	private int length; 
	/** * 宽度 */ 
	private int width; 
	/** * 获得矩形面积 * * @return */ 
	public int area() {
		return this.length * this.width; 
	} 
}
```

我们通过封装的方式，给"矩形"定义了"长度"和"宽度"，这就完成了对现实世界中的"矩形"的抽象的第一步。
### 继承

继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是**从一般到特殊的过程**。

```java
/** * 正方形，继承自矩形 */ 
class Square extends Rectangle {
/** * 设置正方形边长 * * @param length */ 
	public Square(int length) { 
		super(length, length); 
	} 
}
```

现实世界中，"正方形"是"矩形"的特例，或者说正方形是通过矩形派生出来的，这种派生关系体现了**传递性**，在面向对象中可以用继承来表达。

java 中这种传递性还可以通过**实现** 来体现

继承和实现两者的明确定义和区别如下：

**继承（Inheritance）**：如果多个类的某个部分的功能相同，那么可以抽象出一个类出来，把他们的相同部分都放到父类里，让他们都继承这个类。

**实现（Implement）**：如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标

> 继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。所以，继承的根本原因是因为要`复用`，而实现的根本原因是需要定义一个`标准`。

在Java中，继承使用`extends`关键字实现，而实现通过`implements`关键字。

```java
class Car extends Benz implements GasolineCar, ElectroCar{ }
```

Java中支持一个类同时实现多个接口，但是不支持同时继承多个类。

### 多态

所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。**多态机制使具有不同内部结构的对象可以共享相同的外部接口。**

这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。

多态（Polymorphism）指为不同数据类型的**实体**提供统一的**接口**，或使用一个单一的符号来表示多个不同的类型。一般情况下，可以把多态分成以下几类：

- 特设多态：为个体的特定类型的任意集合定义一个共同接口。
- 参数多态：指定一个或多个类型不靠名字而是靠可以标识任何类型的抽象符号。
- 子类型：一个名字指称很多不同的类的实例，这些类有某个共同的超类。

#### java中的多态

Java中的多态的概念比较简单，就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。

Java中多态其实是一种运行期的状态。为了实现运行期的多态，或者说是动态绑定，需要满足三个条件：

- 有类继承或者接口实现
- 子类要**重写**父类的方法
- 父类的引用指向子类的对象

```java
public class Parent{ 
	public void call(){ 
		sout("im Parent"); 
	} 
} 
public class Son extends Parent{// 1.有类继承或者接口实现 
	public void call(){// 2.子类要重写父类的方法 
		sout("im Son"); 
	} 
} 
public class Daughter extends Parent{// 1.有类继承或者接口实现 
	public void call(){// 2.子类要重写父类的方法 
		sout("im Daughter"); 
	} 
} 
public class Test{ 
	public static void main(String[] args){ 
		Parent p = new Son(); //3.父类的引用指向子类的对象 
		Parent p1 = new Daughter(); //3.父类的引用指向子类的对象 
	} 
}
```

重写必须具备以下条件：

1. **参数列表**必须完全与被重写方法的**相同**；
2. **返回类型**必须完全与被重写方法的返回类型**相同**； 
3. **访问级别的限制性一定不能比被重写方法的强**； 
4. **访问级别的限制性可以比被重写方法的弱**； 
5. 重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常 
6. **重写的方法能够抛出更少或更有限的异常**（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）
7. **不能重写被标示为final的方法**；
8. **如果不能继承一个方法，则不能重写这个方法。**


#### 静态多态

上面我们说的多态，是一种运行期的概念。另外，还有一种说法，认为多态还分为**动态多态**和**静态多态**

上面提到的那种动态绑定认为是**动态多态**，因为只有在**运行期**才能知道真正调用的是哪个类的方法。

很多人认为，还有一种**静态多态**，一般认为Java中的**函数重载**是一种**静态多态**，因为他需要在**编译期**决定具体调用哪个方法。

总结下重载和重写这两个概念：

**重载：** 指的是在同一个类中，多个函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。

**重写：** 指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。

1、重载是一个**编译期**概念、重写是一个**运行期**概念。

2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。

3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法。

4、Java中的方法重写是Java多态（子类型）的实现方式。而Java中的方法重写其实是特设多态的一种实现方式。

## 面向对象的五大基本原则

### 单一职责原则

其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。

单一职责原则可以看做是**低耦合、高内聚**在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。
### 开放封闭原则

其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的

开放封闭原则主要体现在两个方面：

1、**对扩展开放**，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。

2、**对修改封闭**，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。

实现开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。
### 里氏替换原则

其核心思想是：**子类必须能够替换其基类**。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。

在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 里氏替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。

里氏替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。

里氏替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。
### 依赖倒置原则（Dependecy-Inversion Principle）

其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。

我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。

依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。

### 接口隔离原则（Interface-Segregation Principle）

其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。

具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。

接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：

1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。

2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。

