# 12.2 深度优先搜索

## [理论基础](https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

## [98. 所有可达路径](https://kamacoder.com/problempage.php?pid=1170)

对应力扣的题目是 [797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)

[讲解](https://programmercarl.com/kamacoder/0098.%E6%89%80%E6%9C%89%E5%8F%AF%E8%BE%BE%E8%B7%AF%E5%BE%84.html#%E6%8F%92%E6%9B%B2)

**邻接矩阵版本代码**，本题题目说是无环图，所以is_visit数组可以不用。

```cpp
#include<iostream>
#include<vector>
using namespace std;
vector<vector<int>> result;
vector<int> path;
void dfs(vector<vector<int>> &graph,vector<int>& is_visit,int x,int n){
    if(x==n){
        result.push_back(path);
        return;
    }
    for(int i = 1;i<=n;i++){
        if(graph[x][i]==1&&is_visit[i]==0){
            path.push_back(i);
            is_visit[i] = 1;
            dfs(graph,is_visit,i,n);
            path.pop_back();
            is_visit[i] = 0;
        }
    }
}
int main(){
    int n,m,s,t;
    cin>>n>>m;
    vector<vector<int>> graph(n+1,vector<int>(n+1,0));
    vector<int> is_visit(n+1,0);
    for(int i = 0;i<m;i++){
        cin>>s>>t;
        graph[s][t] = 1;
    }
    path.push_back(1);
    is_visit[1]=1;
    dfs(graph,is_visit,1,n);
    if (result.size() == 0) cout << -1 << endl;
    for(int i =0;i<result.size();i++){
        for(int j = 0;j<result[i].size()-1;j++)
             cout<<result[i][j]<<" ";
        cout<<result[i][result[i].size()-1]<<endl;
    }
}
```

**邻接表版本代码**

```cpp
#include<iostream>
#include<vector>
#include<list>
using namespace std;
vector<vector<int>> result;
vector<int> path;
void dfs(vector<list<int>> &graph,vector<int>& is_visit,int x,int n){
    if(x==n){
        result.push_back(path);
        return;
    }
    for(int i: graph[x]){
        if(is_visit[i]==0){
            path.push_back(i);
            is_visit[i] = 1;
            dfs(graph,is_visit,i,n);
            path.pop_back();
            is_visit[i] = 0;
        }
    }
}
int main(){
    int n,m,s,t;
    cin>>n>>m;
    vector<list<int>> graph(n+1);
    vector<int> is_visit(n+1,0);
    for(int i = 0;i<m;i++){
        cin>>s>>t;
        graph[s].push_back(t);
    }
    path.push_back(1);
    is_visit[1] = 1;
    dfs(graph,is_visit,1,n);
    if (result.size() == 0) cout << -1 << endl;
    for(int i =0;i<result.size();i++){
        for(int j = 0;j<result[i].size()-1;j++)
             cout<<result[i][j]<<" ";
        cout<<result[i][result[i].size()-1]<<endl;
    }
}
```

## [99. 岛屿数量](https://kamacoder.com/problempage.php?pid=1171)

[讲解](https://programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E6%B7%B1%E6%90%9C.html#%E6%80%9D%E8%B7%AF)

```cpp
#include<iostream>
#include<vector>
using namespace std;
int dirr[4][2]={1,0,0,1,-1,0,0,-1};
int ans=0;
void dfs(vector<vector<int>>& graph, vector<vector<int>>& is_visit,int n,int m,int row,int col){
    for(int i = 0;i<4;i++){
        int nextr = row+dirr[i][0];
        int nextl = col+dirr[i][1];
        if(nextr<0||nextr>=n||nextl<0||nextl>=m) continue;
        if(is_visit[nextr][nextl]==0&&graph[nextr][nextl]==1){
            is_visit[nextr][nextl] = 1;
            dfs(graph,is_visit,n,m,nextr,nextl);
        }
    }
    
}

int main(){
    int n,m;
    cin>>n>>m;
    vector<vector<int>> graph(n,vector<int>(m));
    vector<vector<int>> is_visit(n,vector<int>(m));
    for(int i = 0;i<n;i++){
        for(int j = 0;j<m;j++){
            cin>>graph[i][j];
            is_visit[i][j] = 0;
        }
    }
    for(int i = 0;i<n;i++){
        for(int j = 0;j<m;j++){
            if(is_visit[i][j]==0&&graph[i][j]==1){
                is_visit[i][j] = 1;
                ans++;
                dfs(graph,is_visit,n,m,i,j);
            }
        }
    }
    cout<<ans;
    
}
```

## 100. 岛屿的最大面积

[100. 岛屿的最大面积](https://kamacoder.com/problempage.php?pid=1172)

[讲解](https://programmercarl.com/kamacoder/0100.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.html#%E6%80%9D%E8%B7%AF)