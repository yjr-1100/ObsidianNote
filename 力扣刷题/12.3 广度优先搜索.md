# 12.3 广度优先搜索

## [广度优先搜索理论基础](https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%BF%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B9%BF%E6%90%9C%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)

## [98. 所有可达路径](https://kamacoder.com/problempage.php?pid=1170)

对应力扣的题目是 [797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)

这题使用广度优先需要保存所有路径，每个路径的最后一个节点就是当前节点。

```cpp
class Solution {
public:
    vector<vector<int>> result;
    void bfs(vector<vector<int>>& graph,int x, int n){
        queue<vector<int>> que;
        que.push({x});
        while(!que.empty()){
            vector<int> path = que.front();
            que.pop();
            int node = path[path.size()-1];
            if(node == n){
                result.push_back(path);
            }
            else{
                for(int i = 0;i<graph[node].size();i++){
                        path.push_back(graph[node][i]);
                        que.push(path);
                        path.pop_back();
                }
            }
        }
    }
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        bfs(graph,0,graph.size()-1);
        return result;
    }
};
```

## [99. 岛屿数量](https://kamacoder.com/problempage.php?pid=1171)

力扣连接 [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

[讲解](https://programmercarl.com/kamacoder/0099.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F%E5%B9%BF%E6%90%9C.html)

```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
int dirr[4][2]={1,0,0,1,-1,0,0,-1};
int ans=0;
int n,m;
void bfs(vector<vector<int>>& graph, vector<vector<int>>& is_visit,int row,int col){
    queue<pair<int,int>> que;
    que.push({row,col});
    while(!que.empty()){
        int currrow = que.front().first;
        int currcol = que.front().second;
        que.pop();
        for(int i = 0;i<4;i++){
            int nextr = currrow+dirr[i][0];
            int nextl = currcol+dirr[i][1];
            if(nextr<0||nextr>=n||nextl<0||nextl>=m) continue;
            if(is_visit[nextr][nextl]==0&&graph[nextr][nextl]==1){
                is_visit[nextr][nextl] = 1;
                que.push({nextr,nextl});
            }
        }
    }
}
int main(){
    cin>>n>>m;
    vector<vector<int>> graph(n,vector<int>(m));
    vector<vector<int>> is_visit(n,vector<int>(m));
    for(int i = 0;i<n;i++){
        for(int j = 0;j<m;j++){
            cin>>graph[i][j];
            is_visit[i][j] = 0;
        }
    }
    for(int i = 0;i<n;i++){
        for(int j = 0;j<m;j++){
            if(is_visit[i][j]==0&&graph[i][j]==1){
                is_visit[i][j] = 1;
                ans++;
                bfs(graph,is_visit,i,j);
            }
        }
    }
    cout<<ans;
}
```

## [100. 岛屿的最大面积](https://kamacoder.com/problempage.php?pid=1172)

力扣连接 [LCR 105. 岛屿的最大面积](https://leetcode.cn/problems/ZL6zAn/)

[讲解](https://programmercarl.com/kamacoder/0100.%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.html#%E6%80%9D%E8%B7%AF)

```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
int n,m;
int dirr[4][2] = {1,0,0,1,-1,0,0,-1};
int ans = 0;
int area = 0;
void bfs(vector<vector<int>>& graph,vector<vector<int>>& is_visit,int x,int y){
    queue<pair<int,int>> que;
    que.push({x,y});
    is_visit[x][y] = 1;
    while(!que.empty()){
        int nodex = que.front().first;
        int nodey = que.front().second;
        que.pop();
        area++;
        for(int i = 0;i<4;i++){
            int currx = nodex+dirr[i][0];
            int curry = nodey+dirr[i][1];
            if(curry<0||curry>=m||currx<0||currx>=n) continue;
            if(graph[currx][curry]==1&&is_visit[currx][curry]==0){
                is_visit[currx][curry] = 1;
                que.push({currx,curry});
            }
        }
    }
}
int main(){
    cin>>n>>m;
    vector<vector<int>> graph(n,vector<int>(m));
    vector<vector<int>> is_visit(n,vector<int>(m));
    for(int i = 0;i<n;i++){
        for(int j = 0;j<m;j++){
            cin>>graph[i][j];
            is_visit[i][j] = 0;
        }
    }
    for(int i =0;i<n;i++){
        for(int j = 0;j<m;j++){
            if(graph[i][j]==1&&is_visit[i][j]==0){
                area = 0;
                bfs(graph,is_visit,i,j);
                ans = max(ans,area);
            }
        }
    }
    cout<<ans;
}
```

## [101. 孤岛的总面积](https://kamacoder.com/problempage.php?pid=1173)



```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
int ans = 0;
int n,m;
int dirr[4][2] = {1,0,0,1,-1,0,0,-1};
void bfs(vector<vector<int>>& grid,int x,int y){
    queue<pair<int,int>> que;
    grid[x][y] = 0;
    ans++;
    que.push({x,y});
    while(!que.empty()){
        int x1 = que.front().first;
        int y1 = que.front().second;
        que.pop();
        for(int i = 0;i<4;i++){
            int currx = x1+dirr[i][0];
            int curry = y1+dirr[i][1];
            if(curry<0||curry>=m||currx<0||currx>=n) continue;
            if(grid[currx][curry]==0) continue;
            grid[currx][curry] = 0;
            ans++;
            que.push({currx,curry});
        }
    }
}
int main(){
    cin>>n>>m;
    vector<vector<int>> grid(n,vector<int>(m));
    int count=0;
    for(int i = 0;i<n;i++){
        for(int j = 0;j<m;j++){
            cin>>grid[i][j];
            if(grid[i][j]==1) count++;
        }
    }
    for(int i = 0;i<n;i++){
        if(grid[i][0]==1) bfs(grid,i,0);
        if(grid[i][m-1]==1) bfs(grid,i,m-1);
    }
    for(int j = 0;j<m;j++){
        if(grid[0][j]==1) bfs(grid,0,j);
        if(grid[n-1][j]==1) bfs(grid,n-1,j);
    }
    cout<<count-ans;
}
```

