# 12.6 并查集

## [理论基础](https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9)

```cpp
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
vector<int> father = vector<int> (n, 0); // C++里的一种数组结构
// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩
}
// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}
// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```

# [107. 寻找存在的路径](https://kamacoder.com/problempage.php?pid=1179)

[题解](https://programmercarl.com/kamacoder/0107.%E5%AF%BB%E6%89%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF)

```

```
![[8080b4557f239cc169c7f208c0411691.png]]![[8890857acfdc9f07c43a700028166c6d.png]]
通过95%

```cpp
#include <iostream>
#include<vector>
#include<string>
#include<algorithm>
using namespace std;
int find(int i,int v[]){
  if(v[i]==i) return i;
  else return find(v[i],v);
}
int main(){
  int n,m;
  cin>>n>>m;
  if(n<=1){
    cout<<0;
    return 0;
  }
  if(m==0){
    cout<<n-1;
    return 0;
  }
  int v[n];
  for(int i = 0;i<n;i++) v[i] =i;
  for (size_t i = 0; i < m; i++)
  {
    int a,b;
    cin>>a>>b;
    v[find(a,v)] = find(b,v);
  }
  int ans = n;
  int fa = find(0,v);
  for(int i = 0;i<n;i++){
    if(find(i,v)==fa) ans--;
    else fa = find(i,v);
  }
  cout<<ans;
}
```