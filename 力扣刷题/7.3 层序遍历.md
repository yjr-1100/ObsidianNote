# 7.3 层序遍历

## [102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

一个基本的从上往下的遍历题目

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> ans;
        if(root!=nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();
            vector<int> tmp;
            for(int i = 0;i<size;i++){
                TreeNode* node = que.front();
                que.pop();
                tmp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            ans.push_back(tmp);
        }
        return ans;
    }
};
```

## [107.二叉树的层次遍历II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

从下到上的层序，并且每层从左到右，那就从上到下遍历完了再反转一下

```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> ans;
        queue<TreeNode*> que;
        if(root!=nullptr) que.push(root);
        while(!que.empty()){
            vector<int> tmp;
            int size = que.size();
            for(int i = 0;i<size;i++){
                TreeNode* node = que.front();
                que.pop();
                tmp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            ans.push_back(tmp);
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
};
```

## [199.二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

右视图就是每一层的最后一个，因此还是正常按层遍历，然后最后一个加入vector就可以

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        queue<TreeNode*> que;
        if(root!=nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();
            TreeNode* node;
            for(int i = 0;i<size;i++){
                node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            ans.push_back(node->val);
        }
        return ans;
    }
};
```

## [637.二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

层次遍历，然后相加。

```cpp
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> ans;
        queue<TreeNode*> que;
        if(root!=nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();
            double sum = 0.0;
            for(int i =0;i<size;i++){
                TreeNode* node = que.front();
                que.pop();
                sum+=node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            ans.push_back(sum/size);
        }
        return ans;
    }
};
```

## [429.N叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;
    Node() {}
    Node(int _val) {
        val = _val;
    }
    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> ans;
        queue<Node*> que;
        if(root!=nullptr) que.push(root);
        while(!que.empty()){
            int size = que.size();
            vector<int> tmp;
            for(int i = 0;i<size;i++){
                Node* node = que.front();
                que.pop();
                tmp.push_back(node->val);
                for(int j = 0;j<node->children.size();j++){
                    que.push(node->children[j]);
                }
            }
            ans.push_back(tmp);
        }
        return ans;
    }
};
```

## [515.在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

## [116.填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

## [117.填充每个节点的下一个右侧节点指针II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

## [104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

## [111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

```

```