# 7.19 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

暴力的是直接找到两个节点的路径，然后在路径上找最近的公共祖先

```cpp
class Solution {
public:
    bool getpath(TreeNode* node,vector<TreeNode*>& path,TreeNode* target){
        path.push_back(node);
        if(node==NULL) return false;
        if(node == target) return true;
        if(node->left){
           if(getpath(node->left,path,target)) return true;
           else path.pop_back();
        }
        if(node->right){
            if(getpath(node->right,path,target)) return true;
            else path.pop_back();
        }
        return false;
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        vector<TreeNode*> ppath,qpath;
        getpath(root,ppath,p);
        getpath(root,qpath,q);
        int i =0;
        while(i<ppath.size()&&i<qpath.size()){
            if(ppath[i]==qpath[i]) i++;
            else break;
        }
        return ppath[i-1];
    }
};
```

